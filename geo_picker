#!/usr/bin/env perl
use Mojolicious::Lite -signatures;
use Mojo::Redis;
use Digest::MD5;
use DDP;
use Mojo::JSON qw( to_json );

our $VERSION = 0.01;

use constant {
  OSM_API => 'https://overpass-api.de/api/interpreter',
  DEBUG   => $ENV{GEOPICKER_DEBUG} || 0,
};

helper digest => sub {
  state $h = Digest::MD5->new();
};

helper db => sub {
  state $redis = Mojo::Redis->new->db;
};

helper query_osm => sub ($c, $geom) {

  p $geom if DEBUG;

  # coordinates is giving as [ long, lat ]
  my @coordinates = @{$geom->{geometry}->{coordinates}->[0]};
  my @sorted
    = sort { $a->[0] <=> $b->[0] and $a->[1] <=> $b->[1] } @coordinates;
  my $bottom = shift @sorted;
  my $upper  = pop @sorted;

  # osm query requires [ lat, long ]
  my $str   = join(',', reverse(@$bottom), reverse(@$upper));
  my $query = <<EOQ;
[out:json];
node
  [amenity=school]
  ($str);
out;
EOQ

  p $query if DEBUG;

  # check on redis
  my $res = undef;
  my $key = $c->digest->add($query)->digest();
  $res = $c->db->get($key);

  # redis callback because we already solved
  my $redis_cb = sub {
    my $res = shift;
    $c->app->log->debug('Redis Code');
    $c->render(data => $res, format => 'json');
  };

  return Mojo::Promise->resolve($res), $redis_cb if $res;

  # not found: get from osm server
  $c->app->log->debug('Getting from OSM');

  my $p = $c->app->ua->post_p(
    OSM_API() => {Accept => 'application/json'} => form => {data => $query});

  # osm callback feed cache and render
  my $osm_cb = sub {
    $c->app->log->debug('OSM code');
    my $tx  = shift;
    my $res = $tx->result->body;
    p $res if DEBUG;
    $c->db->set($key, $res);
    $c->render(data => $res, format => 'json');
  };

  return $p, $osm_cb;
};

helper settings => sub( $c ) {

  # TODO: loop through routes and set path to their route names
  return {
    path => {
      url  => $c->url_for('root')->to_abs,
      bbox => $c->url_for('bbox')->to_abs,
    },
    debug => 1,
  };
};

# receive boundbox returning consuting query
post 'geo/bbox' => sub ( $c ) {
  $c->render_later;

  # TODO: subprocess the bound box
  my $geojson = $c->req->json;
  my ($p, $cb) = $c->query_osm($geojson);

  $p->then($cb)
    ->catch(sub ($err) { $c->render(text => "Error: $err", code => 503); });
} => 'bbox';

# index
get '/' => sub ( $c ) {
  $c->render(template => 'index', settings => $c->settings);
} => 'root';

app->start;

__DATA__

@@ index.html.ep
% use Mojo::JSON qw(to_json);
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width,initial-scale=1'>

    <title>Svelte app</title>
    <link rel='icon' type='image/png' href='/favicon.png'>
    <link rel='stylesheet' href='/global.css'>
    <link rel='stylesheet' href='/build/bundle.css'>

    <script>window.__app_settings = <%== to_json $settings %> </script>
    <script defer src='/build/bundle.js'></script>
  </head>

  <body>
  </body>
</html>
